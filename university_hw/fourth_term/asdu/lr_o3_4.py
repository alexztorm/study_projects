"""
Программа моделирования расчёта нефтепровода по заданному алгоритму.
Автор: студент 2-го курса магистратуры по направлению "Автоматизированные системы диспетчерского управления"

Алгоритм:
1. Исходные данные
   - Труба: длина, диаметр, толщина стенки, абсолютная шероховатость
   - Нефть: реология (плотность, вязкость) и скорость звука c
   - Начальные условия: давление в начале (Pₙ) и конце (Pₖ), расчетная температура Tₚ
   - Данные моделирования: число сегментов (dx), время моделирования (число шагов dt),
     изменение граничных условий и момент времени этого изменения

2. Стационарная модель:
   2.1. Создание расчетной сетки модели с шагом dx
   2.2. Вычисление реологии при расчетной температуре (интерполяция вязкости)
   2.3. Предварительный расчет (внутренний диаметр трубы, длина трубы)
   2.4. Итерации для вычисления скорости нефти (она постоянна) по двум точкам
   2.5. Распределение результатов (давление, скорость, плотность, вязкость) по сетке

3. Нестационарная модель (метод характеристик):
   3.1. Проверка, что все точки сетки заполнены параметрами нефти
   3.2. Расчёт шага dt по условию Куранта: dt <= dx/c
   3.3. Создание цикла по времени моделирования
   3.4. Расчёт для шага t1 = t0 + dt
   3.5. Расчёт инвариант системы Ia и Ib (метод характеристик) с граничными условиями:
        Ia = [левый ГУ, I1, I2, …, IN] и Ib = [I0, I1, …, IN-1, правый ГУ]
   3.6. Расчёт давления и скорости на момент t+dt
   3.7. Расчёт давления/скорости на границах с учётом изменения граничных условий
   3.8. Повторение шагов (3.5) – (3.7) до конца моделирования

4. Графики:
   - Построение графиков стационарного расчёта: давление и скорость вдоль трубы
   - Построение динамических графиков нестационарного расчёта с обновлением в цикле по времени

5. Остальные требования:
   - Разбиение кода на функции
   - Оформление графиков (единицы измерения: давление в МПа, расстояние в км и т.д.)

------------------------------------------------------
Импорт необходимых модулей:
------------------------------------------------------
"""
import numpy as np
import matplotlib.pyplot as plt
import math

# ================================
# 1. Исходные данные
# ================================

# Данные трубы (единицы переведены в СИ)
D = 530e-3          # Внешний диаметр трубы, м (530 мм)
delta = 8e-3        # Толщина стенки, м (8 мм)
Delta = 0.19e-3     # Абсолютная шероховатость, м (0,19 мм)

# Геометрия трубы
X0_km = 0           # Начальная координата, км
XN_km = 122.5       # Конечная координата, км

# Данные нефти
rho20 = 842.30      # Плотность при 20°C, кг/м³
nu20 = 14.22e-6     # Кинематическая вязкость при 20°C, м²/с (14,22 сСт -> 14.22e-6 м²/с)
nu50 = 5.90e-6      # Кинематическая вязкость при 50°C, м²/с (5,90 сСт -> 5.90e-6 м²/с)

# Начальные условия
P_n_MPa = 4.11      # Давление в начале трубы, МПа
P_k_MPa = 0.53      # Давление в конце трубы, МПа
T_work = 27.80      # Расчетная (рабочая) температура, °C

# Дополнительные параметры нефти
c_oil = 1400        # Скорость звука в нефти, м/с (принятая оценка)

# Параметры моделирования
num_segments = 100     # Число сегментов (dx) для пространственной сетки

# Параметры нестационарного моделирования
num_time_steps = 1000   # Количество временных шагов моделирования
# Момент времени изменения граничных условий (например, изменение на 50% от времени моделирования)
boundary_change_time = (num_time_steps * (0.9 * ((XN_km*1000)/(c_oil))) )/2


# Функция для интерполяции вязкости при рабочей температуре (Шаг 1 – Вычисление реологии)
def compute_viscosity(T, T1=20.0, T2=50.0, nu1=nu20, nu2=nu50):
    """
    Линейная интерполяция кинематической вязкости между T1 и T2.
    Вход:
      T  - рабочая температура, °C
      nu1 - вязкость при T1, м²/с
      nu2 - вязкость при T2, м²/с
    Выход:
      nu_work - вязкость при температуре T, м²/с
    """
    r = (T - T1) / (T2 - T1)
    return nu1 + r * (nu2 - nu1)

# Вычисляем вязкость при рабочей температуре (Шаг 1 – Нефть: реология)
nu_work_val = compute_viscosity(T_work)

# ================================
# 2. Стационарная модель
# ================================

def stationary_model(D, delta, Delta, X0_km, XN_km, rho, nu, P_n_MPa, P_k_MPa, num_segments):
    """
    Функция расчёта стационарной модели нефтепровода.
    
    Шаг 2.1: Создание расчетной сетки с шагом dx.
    Шаг 2.2: Вычисление реологии при рабочей температуре (уже выполнено вне функции).
    Шаг 2.3: Предварительный расчёт (внутренний диаметр трубы, длина трубы).
    Шаг 2.4: Итеративный расчёт скорости нефти методом подбора с вычислением коэффициента трения.
    Шаг 2.5: Распределение результатов (давление, скорость, плотность, вязкость) по сетке.
    """
    # Вычисляем внутренний диаметр трубы (D внутренний = D внеш. - 2*δ)
    d_internal = D - 2 * delta  # м

    # Перевод координат в метры и расчёт длины трубы
    L_m = (XN_km - X0_km) * 1000  # м

    # Перевод давлений из МПа в Па
    P_n = P_n_MPa * 1e6  # Па
    P_k = P_k_MPa * 1e6  # Па
    deltaP = P_n - P_k  # Па

    # Итерационный расчёт коэффициента трения f и скорости нефти v (Шаг 2.4)
    f = 0.02          # начальное приближение коэффициента трения
    tol = 1e-6
    max_iter = 100
    d = d_internal    # внутренний диаметр трубы в м
    for i in range(max_iter):
        # По уравнению Дарси-Вейсбаха: ΔP = f (L/d) (ρ v^2 / 2)
        v = math.sqrt((2 * deltaP * d) / (rho * L_m * f))
        # Определяем число Рейнольдса
        Re = v * d / nu
        # Вычисляем новый коэффициент трения по формуле Swamee-Jain
        f_new = 0.25 / (math.log10((Delta / (3.7 * d)) + (5.74 / (Re ** 0.9))) ** 2)
        if abs(f_new - f) < tol:
            f = f_new
            break
        f = f_new

    # Расчет градиента давления (падение давления на единицу длины)
    dpdx = f * (rho * v ** 2) / (2 * d)

    # Создание пространственной сетки (Шаг 2.1)
    x = np.linspace(X0_km * 1000, XN_km * 1000, num_segments + 1)  # координата в м

    # Расчет распределения давления по трубе (Шаг 2.5)
    # Принимаем линейное падение давления вдоль трубы
    p = P_n - dpdx * (x - X0_km * 1000)

    # Скорость полагаем постоянной на всю длину трубы (Шаг 2.4)
    u = np.full_like(x, v)

    # Параметры нефти (плотность и вязкость) считаем постоянными по трубе
    density = np.full_like(x, rho)
    viscosity = np.full_like(x, nu)

    return x, p, u, density, viscosity, f, v, dpdx

# Выполняем стационарный расчет
x, p_stationary, u_stationary, density_arr, viscosity_arr, f_val, v_val, dpdx_val = stationary_model(
    D, delta, Delta, X0_km, XN_km, rho20, nu_work_val, P_n_MPa, P_k_MPa, num_segments)

# Функция для построения графиков стационарного расчёта (Шаг 4)
def plot_stationary(x, p, u):
    """
    Построение графиков стационарного расчёта:
    - Давление вдоль трубы (в МПа, координата в км)
    - Скорость нефти вдоль трубы (в м/с)
    """
    plt.figure(figsize=(10, 4))
    plt.subplot(1,2,1)
    plt.plot(x / 1000, p / 1e6, marker='o')
    plt.xlabel("Координата, км")
    plt.ylabel("Давление, МПа")
    plt.title("Стационарное распределение давления")
    plt.grid(True)
    
    plt.subplot(1,2,2)
    plt.plot(x / 1000, u, marker='o', color='orange')
    plt.xlabel("Координата, км")
    plt.ylabel("Скорость, м/с")
    plt.title("Стационарное распределение скорости")
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()

# Отрисовываем графики для стационарного расчёта
plot_stationary(x, p_stationary, u_stationary)

# ================================
# 3. Нестационарная модель (метод характеристик)
# ================================
def nonstationary_model(x, p0, u0, rho, c, num_time_steps, boundary_change_time):
    """
    Функция расчёта нестационарной модели с поправкой на дробное смещение по методу характеристик.
    
    Шаг 3.1: Проверяем, что все точки сетки заполнены параметрами нефти (p0, u0 заданы из стационарного расчёта).
    Шаг 3.2: Расчет шага dt из условия Куранта: dt = 0.9*dx/c.
    Шаг 3.3: Создание цикла по времени моделирования.
    Шаг 3.4: Расчет для шага t1 = t0 + dt.
    Шаг 3.5: Расчет инвариант системы Ia и Ib по методу характеристик с граничными условиями.
         Примечание: Для переноса учитывается дробное смещение, равное r = c*dt/dx (в данном случае r=0.9).
    Шаг 3.6: Обновление давления и скорости: p = ρc(Ia - Ib)/2, u = (Ia + Ib)/2.
    Шаг 3.7: На границах учитывается возможное изменение граничных условий.
    Шаг 3.8: Повторение цикла до завершения моделирования с динамическим обновлением графиков.
    """
    dx = x[1] - x[0]
    dt = 0.9 * dx / c  # dt согласно условию Куранта (Шаг 3.2)
    r = c * dt / dx    # Относительный сдвиг (дробное значение, должно равняться 0.9)

    # Инициализация начальных условий (используем результаты стационарного расчёта)
    p = p0.copy()
    u = u0.copy()

    # Вычисление начальных инвариант (метод характеристик)
    Ia = u + p / (rho * c)
    Ib = u - p / (rho * c)

    # Для накопления истории результатов
    store_interval = max(1, num_time_steps // 20)
    p_history = []
    u_history = []
    t_values = []

    # Настройка динамического обновления графиков (интерактивный режим)
    plt.ion()
    fig, ax = plt.subplots(2, 1, figsize=(10, 8))
    
    for n in range(num_time_steps):
        t = n * dt

        # Шаг 3.7: Изменение граничных условий
        # Например, при t >= boundary_change_time изменяем давление на левом конце (снижение на 10%)
        if t >= boundary_change_time:
            p_left = p0[0] * 0.90  # изменённое левое давление
            u_left = u0[0]         # можно задать новое значение скорости при необходимости
        else:
            p_left = p0[0]
            u_left = u0[0]
        # На правом конце оставляем исходное граничное условие
        p_right = p0[-1]
        u_right = u0[-1]

        # Обновление инвариант с учётом дробного смещения (линейная интерполяция)
        Ia_new = np.empty_like(Ia)
        Ib_new = np.empty_like(Ib)

        # Для инварианты Ia (перемещается вправо)
        # Новое значение в узле x_i: Ia_new(x_i) = I_a(x_i - c·dt)
        # Для i=0 используем граничное условие:
        Ia_new[0] = u_left + p_left / (rho * c)
        for i in range(1, len(Ia)):
            # x_i - c*dt находится между узлами x_{i-1} и x_i, используем линейную интерполяцию:
            Ia_new[i] = (1 - r) * Ia[i-1] + r * Ia[i]

        # Для инварианты Ib (перемещается влево)
        # Новое значение в узле x_i: I_b(x_i) = I_b(x_i + c·dt)
        # Для последнего узла используем граничное условие:
        Ib_new[-1] = u_right - p_right / (rho * c)
        for i in range(0, len(Ib)-1):
            # x_i + c*dt лежит между узлами x_i и x_{i+1}
            Ib_new[i] = (1 - r) * Ib[i+1] + r * Ib[i]

        # Шаг 3.6: Обновление давления и скорости в следующий момент времени
        p = rho * c * (Ia_new - Ib_new) / 2
        u = (Ia_new + Ib_new) / 2

        # Обновляем инварианты для следующего временного шага
        Ia = Ia_new.copy()
        Ib = Ib_new.copy()

        # Сохранение истории
        if n % store_interval == 0:
            p_history.append(p.copy())
            u_history.append(u.copy())
            t_values.append(t)

        # Динамическое обновление графиков (Шаг 4)
        ax[0].cla()
        ax[1].cla()
        ax[0].plot(x / 1000, p / 1e6, 'b-', marker='o')
        ax[0].set_xlabel("Координата, км")
        ax[0].set_ylabel("Давление, МПа")
        ax[0].set_title(f"Динамическое распределение давления, t = {t:.2f} с")
        ax[0].grid(True)

        ax[1].plot(x / 1000, u, 'r-', marker='o')
        ax[1].set_xlabel("Координата, км")
        ax[1].set_ylabel("Скорость, м/с")
        ax[1].set_title(f"Динамическое распределение скорости, t = {t:.2f} с")
        ax[1].grid(True)
        
        plt.pause(0.01)
    
    plt.ioff()
    plt.show()
    return t_values, p_history, u_history, dt

# Выполнение нестационарного расчёта
t_vals, p_hist, u_hist, dt_val = nonstationary_model(
    x, p_stationary, u_stationary, rho20, c_oil, num_time_steps, boundary_change_time)

# Дополнительный вывод: например, можно построить графики эволюции в выбранные моменты времени
def plot_transient_summary(x, t_vals, p_hist, u_hist, num_plots_desired=4):
    """
    Построение итоговых графиков нестационарного расчёта для выбранных моментов времени.
    Выводится заданное число графиков (по умолчанию 4), равномерно распределённых по времени,
    включая начальный и конечный моменты.
    """
    total_snapshots = len(t_vals)
    # Если снимков меньше или равно требуемому числу, выводим их все
    if total_snapshots <= num_plots_desired:
        indices = range(total_snapshots)
    else:
        # Создаем массив индексов, равномерно распределённых от 0 до total_snapshots-1
        indices = np.linspace(0, total_snapshots - 1, num_plots_desired, dtype=int)
    
    n_plots = len(indices)
    plt.figure(figsize=(12, n_plots * 3))
    for i, idx in enumerate(indices):
        plt.subplot(n_plots, 2, 2*i+1)
        plt.plot(x / 1000, p_hist[idx] / 1e6, marker='o')
        plt.xlabel("Координата, км")
        plt.ylabel("Давление, МПа")
        plt.title(f"t = {t_vals[idx]:.2f} с, Давление")
        plt.grid(True)
        
        plt.subplot(n_plots, 2, 2*i+2)
        plt.plot(x / 1000, u_hist[idx], marker='o', color='orange')
        plt.xlabel("Координата, км")
        plt.ylabel("Скорость, м/с")
        plt.title(f"t = {t_vals[idx]:.2f} с, Скорость")
        plt.grid(True)
    plt.tight_layout()
    plt.show()

# Построение итоговых графиков динамики
plot_transient_summary(x, t_vals, p_hist, u_hist)

# ================================
# 5. Основная функция
# ================================
def main():
    # Вывод исходных параметров
    print("Стационарный расчёт:")
    print(f"Внутренний диаметр трубы: {(D - 2*delta)*1000:.2f} мм")
    print(f"Длина трубы: {(XN_km - X0_km)*1000:.2f} м")
    print(f"Расчетная скорость нефти: {v_val:.3f} м/с")
    print(f"Коэффициент трения: {f_val:.5f}")
    print(f"Градиент давления: {dpdx_val/1e6:.5f} МПа/м")
    
    # Графики стационарного расчёта уже построены выше
    
    # Нестационарный расчёт выполнен и динамика показана
    print(f"\nНестационарный расчёт выполнен с dt = {dt_val:.6f} с и числом шагов = {num_time_steps}")

if __name__ == '__main__':
    main()