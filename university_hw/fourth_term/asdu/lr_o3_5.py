"""
Программа моделирования расчёта нефтепровода по заданному алгоритму.
Автор: студент 2-го курса магистратуры по направлению "Автоматизированные системы диспетчерского управления"

Алгоритм:
1. Исходные данные
   - Труба: длина, диаметр, толщина стенки, абсолютная шероховатость
   - Нефть: реология (плотность, вязкость) и скорость звука c
   - Начальные условия: давление в начале и конце, расчетная температура Tр
   - Данные моделирования: число сегментов (dx), число временных шагов (dt),
     изменение граничных условий и момент этого изменения

2. Стационарная модель
   2.1 Создание расчетной сетки с шагом dx
   2.2 Вычисление реологии при расчетной температуре
   2.3 Предварительный расчёт (внутренний диаметр, длина трубы)
   2.4 Итерации для вычисления постоянной скорости по двум точкам (с использованием коэффициента трения)
   2.5 Распределение результата по сетке (давление, скорость, плотность, вязкость)

3. Нестационарная модель
   3.1 Проверка заполненности сетки параметрами нефти
   3.2 Расчёт шага dt по условию Куранта (dt = 0.9·dx/c)
   3.3 Цикл по времени моделирования
   3.4 Расчёт для шага t = t0 + dt
   3.5 Расчёт инвариант системы Ia и Ib (метод характеристик)
   3.6 Обновление давления и скорости: p = ρc(Ia - Ib)/2, u = (Ia + Ib)/2
   3.7 Учёт изменения граничных условий
   3.8 Повторение (с динамической отрисовкой графиков)
   **Изменение для приближения к реальному трубопроводу:**
       - На правой границе применяется не отражающее (открытое) граничное условие:
         вместо жёсткого задания Ib_new[-1] с фиксированным давлением, используем экстраполяцию,
         позволяющую волнам свободно выходить из области моделирования.
         
4. Графики
   - Графики давления и скорости стационарного расчёта
   - Динамические графики нестационарного расчёта

5. Остальные требования:
   - Реализация кода в отдельных функциях
   - Корректное оформление графиков (единицы измерения, подписи осей)
"""

import numpy as np
import matplotlib.pyplot as plt
import math

# ================================
# 1. Исходные данные
# ================================

# Данные трубы (единицы переведены в СИ)
D = 530e-3          # Внешний диаметр трубы, м (530 мм)
delta = 8e-3        # Толщина стенки, м (8 мм)
Delta = 0.19e-3     # Абсолютная шероховатость, м (0,19 мм)

# Геометрия трубы
X0_km = 0           # Начальная координата, км
XN_km = 122.5       # Конечная координата, км

# Данные нефти
rho20 = 842.30      # Плотность при 20°C, кг/м³
nu20 = 14.22e-6     # Кинематическая вязкость при 20°C, м²/с (14,22 сСт)
nu50 = 5.90e-6      # Кинематическая вязкость при 50°C, м²/с (5,90 сСт)

# Начальные условия
P_n_MPa = 4.11      # Давление в начале трубы, МПа
P_k_MPa = 0.53      # Давление в конце трубы, МПа
T_work = 27.80      # Расчетная температура, °C

# Дополнительные параметры нефти
c_oil = 1400        # Скорость звука в нефти, м/с (принятая оценка)

# Параметры моделирования
num_segments = 100     # Число сегментов (dx) для пространственной сетки

# Параметры нестационарного моделирования
num_time_steps = 1000   # Количество временных шагов моделирования
# Момент времени изменения граничных условий (примерное значение)
boundary_change_time = (num_time_steps * (0.9 * ((XN_km*1000)/(c_oil))) )/2

# Функция для интерполяции вязкости при рабочей температуре (Шаг 1 – Вычисление реологии)
def compute_viscosity(T, T1=20.0, T2=50.0, nu1=nu20, nu2=nu50):
    """
    Линейная интерполяция кинематической вязкости между T1 и T2.
    Вход:
      T  - рабочая температура, °C
      nu1 - вязкость при T1, м²/с
      nu2 - вязкость при T2, м²/с
    Выход:
      nu_work - вязкость при температуре T, м²/с
    """
    r = (T - T1) / (T2 - T1)
    return nu1 + r * (nu2 - nu1)

# Вычисляем вязкость при рабочей температуре (Шаг 1 – Нефть: реология)
nu_work_val = compute_viscosity(T_work)

# ================================
# 2. Стационарная модель
# ================================

def stationary_model(D, delta, Delta, X0_km, XN_km, rho, nu, P_n_MPa, P_k_MPa, num_segments):
    """
    Функция расчёта стационарной модели нефтепровода.
    
    Шаг 2.1: Создание расчетной сетки с шагом dx.
    Шаг 2.2: Вычисление реологии при рабочей температуре (вне функции).
    Шаг 2.3: Предварительный расчёт (внутренний диаметр, длина трубы).
    Шаг 2.4: Итерации для вычисления постоянной скорости (с использованием коэффициента трения).
    Шаг 2.5: Распределение результатов по сетке.
    """
    # Вычисляем внутренний диаметр трубы (D внутренний = D внеш. - 2*δ)
    d_internal = D - 2 * delta  # м

    # Перевод координат в метры и расчёт длины трубы
    L_m = (XN_km - X0_km) * 1000  # м

    # Перевод давлений из МПа в Па
    P_n = P_n_MPa * 1e6  # Па
    P_k = P_k_MPa * 1e6  # Па
    deltaP = P_n - P_k  # Па

    # Итерационный расчёт коэффициента трения f и скорости нефти v (Шаг 2.4)
    f = 0.02          # начальное приближение коэффициента трения
    tol = 1e-6
    max_iter = 100
    d = d_internal    # внутренний диаметр трубы в м
    for i in range(max_iter):
        # Уравнение Дарси-Вейсбаха: ΔP = f (L/d) (ρ v^2 / 2)
        v = math.sqrt((2 * deltaP * d) / (rho * L_m * f))
        # Определяем число Рейнольдса
        Re = v * d / nu
        # Вычисляем новый коэффициент трения (формула Swamee-Jain)
        f_new = 0.25 / (math.log10((Delta / (3.7 * d)) + (5.74 / (Re ** 0.9))) ** 2)
        if abs(f_new - f) < tol:
            f = f_new
            break
        f = f_new

    # Расчет градиента давления
    dpdx = f * (rho * v ** 2) / (2 * d)

    # Создание пространственной сетки (Шаг 2.1)
    x = np.linspace(X0_km * 1000, XN_km * 1000, num_segments + 1)  # координата в м

    # Расчет распределения давления (линейное падение давления)
    p = P_n - dpdx * (x - X0_km * 1000)

    # Скорость постоянна по всей длине трубы (Шаг 2.4)
    u = np.full_like(x, v)

    # Параметры нефти (плотность и вязкость) считаем постоянными
    density = np.full_like(x, rho)
    viscosity = np.full_like(x, nu)

    return x, p, u, density, viscosity, f, v, dpdx

# Выполнение стационарного расчёта
x, p_stationary, u_stationary, density_arr, viscosity_arr, f_val, v_val, dpdx_val = stationary_model(
    D, delta, Delta, X0_km, XN_km, rho20, nu_work_val, P_n_MPa, P_k_MPa, num_segments)

# Функция для построения графиков стационарного расчёта (Шаг 4)
def plot_stationary(x, p, u):
    """
    Построение графиков стационарного расчёта:
    - Давление вдоль трубы (в МПа, координата в км)
    - Скорость нефти вдоль трубы (в м/с)
    """
    plt.figure(figsize=(10, 4))
    plt.subplot(1,2,1)
    plt.plot(x / 1000, p / 1e6, marker='o')
    plt.xlabel("Координата, км")
    plt.ylabel("Давление, МПа")
    plt.title("Стационарное распределение давления")
    plt.grid(True)
    
    plt.subplot(1,2,2)
    plt.plot(x / 1000, u, marker='o', color='orange')
    plt.xlabel("Координата, км")
    plt.ylabel("Скорость, м/с")
    plt.title("Стационарное распределение скорости")
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()

# Отрисовываем графики стационарного расчёта
plot_stationary(x, p_stationary, u_stationary)

# ================================
# 3. Нестационарная модель (метод характеристик)
# ================================
def nonstationary_model(x, p0, u0, rho, c, num_time_steps, boundary_change_time):
    """
    Функция расчёта нестационарной модели с поправкой на дробное смещение по методу характеристик.
    
    Шаги:
    3.1 Проверка заполненности сетки параметрами (используем результаты стационарного расчёта).
    3.2 Расчёт dt согласно условию Куранта: dt = 0.9*dx/c.
    3.3 Цикл по времени моделирования.
    3.4 Расчёт состояния для t = t0 + dt.
    3.5 Расчёт инвариант Ia и Ib (сдвиг с линейной интерполяцией).
    3.6 Обновление p и u: p = ρc*(Ia - Ib)/2, u = (Ia + Ib)/2.
    3.7 Изменение граничных условий.
    3.8 Повторение цикла до окончания моделирования с динамической отрисовкой.
    
    **Изменение для приближения к реальному трубопроводу:**
    На правой границе вместо жёсткого задания граничного условия для Ib_new[-1] используется экстраполяция (не отражающее условие),
    позволяющая волнам свободно выходить из области.
    """
    dx = x[1] - x[0]
    dt = 0.9 * dx / c  # Шаг по времени согласно условию Куранта
    r = c * dt / dx    # Относительный сдвиг (дробное значение, r = 0.9)

    # Инициализация начальных условий (результаты стационарного расчёта)
    p = p0.copy()
    u = u0.copy()

    # Вычисление начальных инвариант (Ia и Ib)
    Ia = u + p / (rho * c)
    Ib = u - p / (rho * c)

    # Для сохранения истории результатов
    store_interval = max(1, num_time_steps // 20)
    p_history = []
    u_history = []
    t_values = []

    # Настройка динамических графиков (интерактивный режим)
    plt.ion()
    fig, ax = plt.subplots(2, 1, figsize=(10, 8))
    
    for n in range(num_time_steps):
        t = n * dt

        # Шаг 3.7: Изменение граничных условий
        # На левом конце по-прежнему задаём фиксированное давление (при необходимости изменяем его)
        if t >= boundary_change_time:
            p_left = p0[0] * 0.90  # изменённое давление на входе
            u_left = u0[0]
        else:
            p_left = p0[0]
            u_left = u0[0]
        # Для правого конца (выход) сохраняем условие открытого (не отражающего) выхода:
        # Здесь не задаём фиксированное значение, а используем экстраполяцию, чтобы волна уходила из системы.
        
        # Обновление инвариант с учетом дробного смещения (линейная интерполяция)
        Ia_new = np.empty_like(Ia)
        Ib_new = np.empty_like(Ib)

        # Инварианта Ia (перенос вправо)
        Ia_new[0] = u_left + p_left / (rho * c)  # граничное условие на левом конце
        for i in range(1, len(Ia)):
            # Интерполяция: значение в точке x_i определяется из значений в x_{i-1} и x_i
            Ia_new[i] = (1 - r) * Ia[i-1] + r * Ia[i]
        
        # Инварианта Ib (перенос влево)
        # Для внутренних узлов используем интерполяцию:
        for i in range(0, len(Ib)-1):
            Ib_new[i] = (1 - r) * Ib[i+1] + r * Ib[i]
        # **Ключевое изменение:**
        # Вместо жёсткого задания правой границы с фиксированным давлением
        # устанавливаем экстраполяцию (не отражающее условие), позволяющую волне свободно выходить:
        Ib_new[-1] = 2*Ib_new[-2] - Ib_new[-3]
        
        # Шаг 3.6: Обновление давления и скорости
        p = rho * c * (Ia_new - Ib_new) / 2
        u = (Ia_new + Ib_new) / 2

        # Обновляем инварианты для следующего шага
        Ia = Ia_new.copy()
        Ib = Ib_new.copy()

        # Сохранение истории для постобработки
        if n % store_interval == 0:
            p_history.append(p.copy())
            u_history.append(u.copy())
            t_values.append(t)

        # Динамическое обновление графиков (Шаг 4)
        ax[0].cla()
        ax[1].cla()
        ax[0].plot(x / 1000, p / 1e6, 'b-', marker='o')
        ax[0].set_xlabel("Координата, км")
        ax[0].set_ylabel("Давление, МПа")
        ax[0].set_title(f"Динамическое распределение давления, t = {t:.2f} с")
        ax[0].grid(True)

        ax[1].plot(x / 1000, u, 'r-', marker='o')
        ax[1].set_xlabel("Координата, км")
        ax[1].set_ylabel("Скорость, м/с")
        ax[1].set_title(f"Динамическое распределение скорости, t = {t:.2f} с")
        ax[1].grid(True)
        
        plt.pause(0.01)
    
    plt.ioff()
    plt.show()
    return t_values, p_history, u_history, dt

# Выполнение нестационарного расчёта с новой правой (выходной) границей
t_vals, p_hist, u_hist, dt_val = nonstationary_model(
    x, p_stationary, u_stationary, rho20, c_oil, num_time_steps, boundary_change_time)

# ================================
# Графики итоговой динамики
# ================================
def plot_transient_summary(x, t_vals, p_hist, u_hist, num_plots_desired=4):
    """
    Построение итоговых графиков нестационарного расчёта для выбранных моментов времени.
    Выводится заданное число графиков (по умолчанию 4), равномерно распределённых по времени,
    включая начальный и конечный моменты.
    """
    total_snapshots = len(t_vals)
    if total_snapshots <= num_plots_desired:
        indices = range(total_snapshots)
    else:
        indices = np.linspace(0, total_snapshots - 1, num_plots_desired, dtype=int)
    
    n_plots = len(indices)
    plt.figure(figsize=(12, n_plots * 3))
    for i, idx in enumerate(indices):
        plt.subplot(n_plots, 2, 2*i+1)
        plt.plot(x / 1000, p_hist[idx] / 1e6, marker='o')
        plt.xlabel("Координата, км")
        plt.ylabel("Давление, МПа")
        plt.title(f"t = {t_vals[idx]:.2f} с, Давление")
        plt.grid(True)
        
        plt.subplot(n_plots, 2, 2*i+2)
        plt.plot(x / 1000, u_hist[idx], marker='o', color='orange')
        plt.xlabel("Координата, км")
        plt.ylabel("Скорость, м/с")
        plt.title(f"t = {t_vals[idx]:.2f} с, Скорость")
        plt.grid(True)
    plt.tight_layout()
    plt.show()

# Вывод итоговых графиков динамики в 5-6 моментах времени
plot_transient_summary(x, t_vals, p_hist, u_hist, num_plots_desired=4)

# ================================
# 5. Основная функция
# ================================
def main():
    print("Стационарный расчёт:")
    print(f"Внутренний диаметр трубы: {(D - 2*delta)*1000:.2f} мм")
    print(f"Длина трубы: {(XN_km - X0_km)*1000:.2f} м")
    print(f"Расчетная скорость нефти: {v_val:.3f} м/с")
    print(f"Коэффициент трения: {f_val:.5f}")
    print(f"Градиент давления: {dpdx_val/1e6:.5f} МПа/м")
    
    print(f"\nНестационарный расчёт выполнен с dt = {dt_val:.6f} с и числом шагов = {num_time_steps}")
    print("Результаты нестационарного расчёта отражают открытую (не отражающую) правую границу, "
          "ближе соответствующую реальному магистральному трубопроводу.")

if __name__ == '__main__':
    main()
